Printing all combinations of K out of N elements
================================================
vector<int> people;//contains the N elements
vector<int> combination;

void go(int offset, int k) {
  if (k == 0) {
    return (combination);//new combination found
  }
  for (int i = offset; i <= people.size() - k; ++i) {//"the people.size()-k" so as to be able to fit another k elements
    combination.push_back(people[i]);
    go(i+1, k-1);
    combination.pop_back();
  }
}


All Permutations of N elements
==============================
vector<int> people;//contains the N elements
do{...}while(next_permutation(people.begin(),people.end()));

All Combinations of N elements
==============================
vector <char> People  = {'a','b','c','d'};// size less than 32 since "i" is integer of 32 bits
  for(int i=0; i< (1<<People.size()); ++i) {
      for(int pos=0; pos<People.size(); pos++)  if (i & (1<<pos)) cout << People[pos];        
      cout << endl;
  }


Create 2D matrices as arguments
===============================
Do not try to create a 2D matrix that its dimensions are defined on the run (with cin >> ) and pass it 
to a function as an argument. Always I have troubles with  "new" command. Either use
vector <int> A[n]; for(int i=0;i<m;i++) A.push_back(...); and pass it as argument in function "vector<int> A[]"
or just define a global big (using the problem's constraint) 2D array.

Complexities
================================================
Depending on the size of the input ("n") you can suspect the complexity of the 
"best" solution and what it might involve:
n<10: O(n!) ....Permutations
n<20: O(2^n)....Iterate over all subsets, combinations
n<500:O(n^3)....3 nested loops, possible to get through all triplets of the input elements
n<5e3:O(n^2)....2 nested loops, possible to get through all pairs of the input elements
n<1e6:O(n*logn) OR O(n)... you can sort or use a data structure where each operation takes 
                           up to O(nl*ogn) time and do that operation per input element
n is large: O(1) OR O(logn)... find a direct formula or  something that halves the input 
                               size per step.


Too Slow...
===============================================
-More than 10.000 insertions in an <unordered_set>
-


Sorting but keeping indexes
================================================
#include <numeric>      // std::iota
....

vector <int> v;
... cin >> v[i]...
vector<size_t> idx(v.size());
iota(idx.begin(), idx.end(), 0);

// sort indexes based on comparing values in v using std::stable_sort instead of std::sort
// to avoid unnecessary index re-orderings when v contains elements of equal values 
stable_sort(idx.begin(), idx.end(), [&v](size_t i1, size_t i2) {return v[i1] < v[i2];});///ASCENDING ORDER
sort(numbers.rbegin(), numbers.rend());  IS better than sort(numbers.begin(), numbers.end(), std::greater<int>()); 
    for descending order sorting because it will not mess up when it comes for long long int input. ///DESCENDING ORDER


Do NOT iterate through a container and change it
================================================
vector <int> V={1,3,5};
for (auto x:V)  V.push_back(x);//It gave different results per run. Once V was {1 3 5 1 524 -1483472560} !!!???
                      //Same will haven also if you use for(auto & x:V) or for(auto const x:V) or for(auto const & x:V)

Also the following will run indefinetely
vector <int> V={1,3,5};
for(int i=0; i<V.size(); i++) V.push_back(i);


Adding & removing elements from a structure but able to query how many of the remaining elements are smaller/bigger
================================================
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp>
using namespace __gnu_pbds;  
#define ordered_set tree<int, null_type,less<int>, rb_tree_tag,tree_order_statistics_node_update>
ordered_set s; // it has all the functionalities of the normal c++ sets plus the two following functions
*(s.find_by_order(k))//finds the k-th biggest element
s.order_of_key(x) // finds the index/position of x element

LOWER_BOUND and upper_bound
===========================
In case you have a vector V (example 10 20 20 30 30):
-lower_bound: You use "V[i] cmp val". In the default case where cmp is < you can think
as scanning from left to right the vector and the first i giving "V[i] cmp val" False is the output.
(if T is True and F False then in the example "lower_bound(V.begin(), V.end(), 20)"
will see the comparisons T F F F F F... so the output is position 1)

-upper_bound: You use "val cmp V[i]". In the default case where cmp is < you can think
as scanning from left to right the vector and the first i giving "val cmp V[i]" True  is the output.
(if T is True and F False then in the example "upper_bound (V.begin(), V.end(), 20)"
will see the comparisons F F F T T ... so the output is position 3)

To understand better how they work check the code in https://cplusplus.com/reference/algorithm/lower_bound/ 
showing the behavior of lower_bound function


Create sorted vector without duplicates
=======================================
  sort(V.begin(),V.end());
  auto it = unique(V.begin(), V.end())
  V.erase(it, V.end());//instead you could also use V.resize( distance(V.begin(),it) );


Locally checking code
===========================
Create the files in.txt and out.txt on the same directory and use the commands below...
  freopen("in.txt", "r", stdin);
  freopen("out.txt", "w", stdout);


Creating a vector of pointers to vectors
========================================'
//I am unsure if the following code is a good use of C++
vector <vector <int> *> V;//for each city it shows the component the city belongs
for(int i=0; i<n; i++) {
    V.push_back(new vector<int>);
    V[i]->push_back(2*i);//Each vector is initialized having one element of value 2*i
}
V[1]->at(0) = 32;//Changing the second vector's first element to 32


Multiset-tips
=============
Be careful if you use the multiset S has many times the value "x" and then 
S.count(x) can be linear to S.size()!
If you want to remove only one "x" from the multiset do S.erase(S.find(x)) 
because S.erase(S.find(x)) will erase all the elements of S with value x.


General advices
================================================
DO NOT FORGET TO INITIALIZE EVERYTHING

#include <bits/stdc++.h> ->including all standard libraries

g++ -std=c++11 -02 test.cpp -o main.exe ->...to compile with c++11

ios::sync_with_stdio(0); cin.tie(0); //FASTER input output ... Especially if you have many cin/cout is good.
use "\n" instead of endl for speed //FASTER ... Especially if you have many "cout" do it!

string s; getline(cin,s) // to read a whole line maybe with spaces

int -> -2e9 till 2e9
long long -> 2e18 till 2e18

int a = 123456789; long long b=a*a; //b will be -1757895751 !!!!

(a + b)%m  == (a%m + b%m)%m !!! it holds not only for "+" but also for "-","*"
SOS... (-a)%m == -(a%m) and with the "-" operator be careful if you end up with negative numbers:
example: (3-7)%5 =-4 and 3%5 - 7%5=1 ... but 1 and -4 are equal in modulo 5 arithmetics. 

In cpp if x<0 then x%m<0... to make it positive just add m
i.e. if (x%m < 0) cout << (x%m+m);

Whenever you can pass arguments by reference to a function... If the function is called many times this 
can save you a lot of time.


double x = 0.3*3+0.1;  //x=0.99999999999999988898
printf("%.10f\n",x);   //prints 1.0000000000
if (x != 1.0) cout << "not equal" //will not print it
else if (abs(x-1.0)<1e-9) cout<<"equal"; //better way to compare float numbers


When you do recursiion find a way not to create/copy new variables in every recursion.

BE CAREFUL in data structures like vector you are allowed to "access" even in positions
that are greater than their size. e.g. vector <int> P(N); cout << P[N];... 

BE CAREFUL when passing data structures like "vector" as argument in a function. If 
you do not use the "&" it will copy all the data structure!!! CAN TAKE LOTS OF TIME 

CAREFUL when you need to divide and you give the answers in MODULO md...! 

AVOID DECLARING VARIABLES IN FOR/IF LOOPS. For example:
vector<vector <int> *> P(1);
if (true){
  vector<int> G={4,5};
  P[0] = &G;
  cout << (*P[0])[0] <<" " << (*P[0])[1] << endl;//prints  4 5
}
cout << (*P[0])[0] <<" " << (*P[0])[1] << endl;//prints  0 0


vector< vector <int>> P;
vector<int>v(2);
for (int i=0;i<2; i++){
  v[0]=i;
  v[1]=i+1;
  P.push_back(v); //will store a COPY OF v
}
for(auto q:P) {
  cout<< q[0] << "-"<< q[1]<<"  ";//will print 0-1  1-2  
}


If you have a Dynamic Prog. problem where you want to choose objects such that...
and you can use multiple times one object it is better NOT to design the algorithm
such that in every iteration you include a new object (which you consider using
it multiple times)


If you want to insert in a structure numbers that are given randomly but you want them
to be kept in order then it is faster to just use <set> than a <list> where you insert 
a new number x in the position given by the iterator upper_bound(myList.begin(), myList.end(), x);...

Interanlly, the elements in a set are always sorted... So the order is in a increasing order
and not in the order that the elements were inserted!

In an "map" or "set" accessing or finding an element is logarithmic to the size of the 
structure. Doing it more than 100.000 might cost you more than a second... beware...
If you have for some reason (maybe you just did a find operation just before and you
kept the position with an iterator) the iterator pointing to the element, use it. It's O(1)!
I found that showing the position is good also for inserting in a set but for erasing it takes 
lot of time (100.000 is too much).

An iterator for set is not random-access iterator so using "advance" takes 
linear time to the step you "advance"

Reverse iterator is different than (forward) iterator... you cannot assign one to the other.

tie(a, b ,c) = e

//when you have a labyrinth and you want to iterate over all possible next moves...
map <char, pair<int, int>> Moves={ {'D',{1,0}}, {'U',{-1,0}}, {'R',{0,1}}, {'L',{0,-1}}};
for (auto const& move: Moves){
  Direction = move.first;
  tie(incr_x, incr_y) = move.second;
  ...


#define INF 8e18//for long long 9e18 is the maximum... I put a bit less so as to be able to add a 
number (less than 1e18...) without going to the minus

Maybe if you define arrays of size  you will have memory problems
and the problem will exit without any warning/error!!!
Strangely if you define the array outside (and before) the int main(){} then it may work!!!???

In a problem I could either use an array "int X[5000][5000]" for the solution or rewriting the code 
and use instead an array "int X[5000][2]"...The second way was 10 times faster!!! (from 0.2s to 0.02s)


NICE PROBLEMS
===============================================
Check again the problems 03_Coin Combinations I and II that depending on
the order of the loops will either give you the number of combinations 
of coins summing up to X or permutations summing up to X.


Some gits command
====================

Most used commands :
- clone repo : `git clone`
- add remote `git remote add origin <PATH of .git>` (git init first)
- create branch `git checkout -b newbranch`
- change branch `git checkout master`
- add all files : `git add .`
- create commit + commentary : `git commit -m "some commit"`
- push to remote : `git push origin some_remote_branch`
- get modifications and try to merge : `git pull`
(first init -> add -> commit -> push ??)

Other commands : 
- get modif without merging : `git fetch`
- show changes : `git diff`
- merge branch featureA into current : `git merge featureA`
- commit when forgot smthg :   `git commit --amend --no-edit`
